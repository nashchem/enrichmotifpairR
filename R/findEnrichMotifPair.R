#' Finds enriched motifs and their binding partner motifs in a given
#' genomic regions.
#'
#' @param target_data A data frame containing peaks coordinates with chr, start,
#' and end as first three columns
#' @param background_data Same as "target_data"
#' @param genome_ver Genome version, it should be either "hg19" or "hg38"
#' @param scramble_data A logical value (TRUE/FALSE) whether background data
#' need to be generated by scrambling target_data, by default FALSE
#' @param motif_database A character representing motif database to choose from,
#' it should be one or more of c("JASPAR_CORE", "ENCODE", "CISBP", "HOMER", "HOCOMOCO",
#' "JASPAR_UNVALIDATED"), default = "CISBP"
#' @param Pvalue_computation A character representing P value computations are
#' either based on binomial or hyper geometric distributions, it should be one
#' of c("binom", "hyper"), default = "binom"
#' @param Pvalue_threshold A numeric value for filtering the enriched motifs and
#' motif pairs
#' @param Pvalue_adjust_method A character representing method for adjustig the
#' P values for multple comparisons, it should be one or more of
#' c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")
#' default = "BH"
#' @return A list with two data frames containing enriched motifs and motif
#' pairs with P-values, fold-enrichment and annotations
#' @examples
#' \dontrun{
#' findEnrichMotifPair(target_data, background_data = NULL,
#' genome_ver = "hg38", scramble_data = TRUE)
#' }
#' @import stats
#' @importFrom motifmatchr matchMotifs
#' @importFrom GenomicRanges makeGRangesFromDataFrame
#' @importFrom rlang .data
#' @importFrom SummarizedExperiment assays
#' @importFrom dplyr inner_join
#' @importFrom dplyr %>%
#' @importFrom assertthat assert_that
#' @export
#'
#'
findEnrichMotifPair = function(target_data, background_data = NULL,
                           genome_ver = "hg38", scramble_data = T,
                           motif_database = "CISBP",
                           Pvalue_computation = "hyper",
                           Pvalue_threshold = 0.05,
                           Pvalue_adjust_method = "BH"){
    # checking input data and parameters
    assertthat::assert_that(is.data.frame(target_data))
    assertthat::assert_that(is.character(genome_ver))
    assertthat::assert_that(is.logical(scramble_data))
    assertthat::assert_that(is.character(motif_database))
    assertthat::assert_that(is.character(Pvalue_computation))
    assertthat::assert_that(is.numeric(Pvalue_threshold))
    assertthat::assert_that(is.character(Pvalue_adjust_method))

    # loading the right genome based on user choice
    if(genome_ver == "hg19"){
        genome_data <- BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19
    } else {genome_data <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38}

    colnames(target_data)[1:3] = c("chr", "start", "end")
    target_data <- target_data %>% dplyr::filter(grepl("chr[0-9]{1,2}$|[XY]$", chr))
    
    # checking if background data is provided by user
    if(is.null(background_data) & !scramble_data){
        bg_gr <- generateBackgroundSeqs(input_data = target_data,
                                                  genome_ver = genome_ver)
        message("background data is generated by matched GC, length and chromosome distribution")
    } else {message("background data is provided by the user or generated by scrambling the input sequences")}

    if(is.null(background_data) & scramble_data){
        bg_gr <- generateScrambleSeqs(input_data = target_data,
                                                    genome_ver = genome_ver)
        message("background data is generated by scrambling the input sequences")
        }

    # convert data into GRanges objects

    if(!is.null(background_data)){
        colnames(background_data)[1:3] = c("chr", "start", "end")
        background_data <- background_data %>% dplyr::filter(grepl("chr[0-9]{1,2}$|[XY]$", chr))
        bg_gr <- background_data %>% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE, ignore.strand = TRUE)
    }
    
    message("Check point 1 passed")
    colnames(target_data)[1:3] = c("chr", "start", "end")
    tg_gr <- target_data %>% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE, ignore.strand = TRUE)
    message("Check point 2 passed")
    # extract relevant motifs PWM and their annotation based on motif database
    filter_col <- function(df1, col_name, val) {
        col_name <- dplyr::enquo(col_name) # captures the environment in which the function was called
        df1 %>% dplyr::filter((!!col_name) %in% val)
    }

    filter_col2 <- function(df1, col_name, val) {
        col_name <- dplyr::enquo(col_name) # captures the environment in which the function was called
        df1 %>% dplyr::filter((!!col_name) == val)
    }
    motif_database <- "CISBP"
    motif_anno <- filter_col(motif_anno_data, .data$motif_source, motif_database)
    motif_anno
    #motif_anno <- base::subset(motif_anno_data, motif_source == motif_database)
    message("Check point 3 passed")
    idx <- base::match(motif_anno[,1], names(all_motifs))
    message("Check point 4 passed")
    motifs_PWMs <- all_motifs[idx]
    message("Check point 5 passed")
    
    # find motif locations
    tryCatch(
        motif_ix_scores_tg <- motifmatchr::matchMotifs(motifs_PWMs, tg_gr, out = "scores", genome = genome_data),
        error = function(err) {
            msg <- conditionMessage(err)
            if (grepl("trying", msg)) {
                new_msg <- 
                    paste0("trying to load regions beyond the boundaries of ", genome_ver, ":  make sure you are using the correct genome")
                stop(new_msg)
            }
            stop(err)
            }
        )
    
    tryCatch(
        motif_ix_scores_bg <- motifmatchr::matchMotifs(motifs_PWMs, bg_gr, out = "scores", genome = genome_data),
        error = function(err) {
            msg <- conditionMessage(err)
            if (grepl("trying", msg)) {
                new_msg <- 
                    paste0("trying to load regions beyond the boundaries of ", genome_ver, ":  make sure you are using the correct genome")
                stop(new_msg)
            }
            stop(err)
        }
    )
    message("Check point 6 passed")

    f1 <- SummarizedExperiment::assays(motif_ix_scores_tg)$motifMatches
    f2 <- SummarizedExperiment::assays(motif_ix_scores_bg)$motifMatches
    # save(f1, f2, file = "tt.rda")
    # compute P-value and Fold enrichment
    motif_pval <- function(tg2 = f1, bg2 = f2, Pval_dist = Pvalue_computation){
        tg_mf_c1 <- data.frame(motif_name = colnames(tg2), tg_motif_count = Matrix::colSums(tg2), row.names = NULL, stringsAsFactors = FALSE)
        bg_mf_c1 <- data.frame(motif_name = colnames(bg2), bg_motif_count = Matrix::colSums(bg2), row.names = NULL, stringsAsFactors = FALSE)

        tg_bg_mf_c <- dplyr::inner_join(tg_mf_c1, bg_mf_c1)
        tg_bg_mf_c$fold_enrich <- ((tg_bg_mf_c$tg_motif_count + 0)/(dim(tg2)[1] + 0))/((tg_bg_mf_c$bg_motif_count + 0)/(dim(bg2)[1] + 0))

        # computes P-values based on binomial distribution
        compute_pval_binom <- function(data1 = data1, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1]){
            return(binom.test(x = data1[1], n = tot_tg, p = data1[2]/tot_bg, alternative = "greater")$p.value)
        }

        # computes P-values based on hypergeometric distribution or fisher's exact test
        compute_pval_hyper <- function(data1 = data1, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1]){
            return(phyper(q = data1[1]-1, m = (data1[1] + data1[2]), n = (tot_tg + tot_bg) - (data1[1] + data1[2]), k = tot_tg, lower.tail = FALSE, log.p = FALSE))
        }

        if(Pvalue_computation == "binom"){
            tg_bg_mf_c$pval <- apply(X = tg_bg_mf_c[,2:3], MARGIN = 1, FUN = compute_pval_binom, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1])
        } else (tg_bg_mf_c$pval <- apply(X = tg_bg_mf_c[,2:3], MARGIN = 1, FUN = compute_pval_hyper, tot_tg = dim(tg2)[1], tot_bg = dim(bg2)[1]))
        return(tg_bg_mf_c)
    }

    motif_enrich <- motif_pval(tg2 = f1, bg2 = f2, Pval_dist = Pvalue_computation)
    motif_enrich <- dplyr::inner_join(motif_enrich, motif_anno[, 1:2])
    motif_enrich$pval_adj <- p.adjust(motif_enrich$pval, method = Pvalue_adjust_method)
    motif_enrich <- motif_enrich[, c(1,6,2:5,7)] %>% dplyr::filter(.data$pval_adj < Pvalue_threshold) %>% dplyr::arrange(pval_adj)
    message("Check point 7 passed")
    data_res2 <- motif_enrich 
    if (nrow(data_res2) == 0){
        stop(paste0("No significant motifs found at Pvalue threshold: ", Pvalue_threshold))
    }

    data_2motif <- NULL
    data_res2
    for (k in 1:dim(data_res2)[1]){
        m1 <- data_res2$motif_name[k]
        idx_m <- match(m1, colnames(f1))

        # find motifs with same fold enrichment
        fold_val <- data_res2$fold_enrich[k]
        motif_similar <- filter_col2(data_res2, .data$fold_enrich, fold_val)
        idx_sm <- match(motif_similar$motif_name, colnames(f1))

        f1_1 <- f1[f1[,idx_m], -idx_sm]
        f2_1 <- f2[f2[,idx_m], -idx_sm]

        data_2motif_temp <- motif_pval(tg2 = f1_1, bg2 = f2_1, Pval_dist = Pvalue_computation)
        data_2motif_temp$pval_adj <- p.adjust(data_2motif_temp$pval, method = Pvalue_adjust_method)
        data_2motif_temp$motif_name_1 <- m1
        data_2motif_temp <- data_2motif_temp %>% dplyr::arrange(pval_adj)
        data_2motif <- rbind(data_2motif, data_2motif_temp)
    }
    data_2motif_1 <- dplyr::inner_join(data_2motif, motif_anno[, 1:2], by = c("motif_name_1" = "motif_name"))
    colnames(data_2motif_1)[c(1,8)] <- c("motif_name_2", "TF_name_1")
    data_2motif_2 <- dplyr::inner_join(data_2motif_1, motif_anno[, 1:2], by = c("motif_name_2" = "motif_name"))
    # re-arrange the columns
    data_2motif_3 <- data_2motif_2[, c(7,8,1,9,4,5,6)]
    colnames(data_2motif_3)[4] <- "TF_name_2"
    data_2motif_4 <- data_2motif_3 %>% dplyr::filter(.data$pval_adj < Pvalue_threshold)

    # get rid off the inf values if any
    data_2motif_4 <- data_2motif_4 %>% dplyr::filter_if(~is.numeric(.), dplyr::all_vars(!is.infinite(.)))
    motif_enrich <- motif_enrich %>% dplyr::filter_if(~is.numeric(.), dplyr::all_vars(!is.infinite(.)))
    motif_res <- list(motif_enrich = motif_enrich, motif_pair_enrich = data_2motif_4)
    return(motif_res)
    
}




